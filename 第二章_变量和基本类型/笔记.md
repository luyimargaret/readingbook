# 含有无符号数的运算，首先有符号数被转化为无符号数
# 初始化与赋值
初始化是创建变量时给一个初始值，赋值含义是把当前对象擦除，以一个新值代替
# 为了程序安全初始化每个一内置型的变量
# 变量的声明和定义：
声明使得一个名字被程序知道，一个文件想使用别处定义的名字，则必须包含对那个名字的声明。而定义负责创建与名字关联的实体。
变量声明规定了变量的类型和名字，而定义除此之外还申请了存储空间。
如果想声明一个变量而非定义，就在变量名前添加关键字extern，而且不要显式地初始化变量。如果初始化了，那就是定义。
extern int i;   //声明而非定义
int i;           //声明且定义
在函数体内，初始化一个extern标记的变量会引发错误。
变量能且只能被定义一次，但是可以多次被声明。
"多个文件中使用同一变量的话，变量的定义只能出现在一个文件中，其他用到该变量地文件必须对其声明。"
# 第一次使用变量时再定义它。
# 指针和引用的联系和区别：
    联系：指针和引用都能实现堆其他对象的间接访问。
    区别：
    指针本身就是一个对象，允许对指针赋值和拷贝，而且在生命周期内它可以先后指向几个不同的对象。引用本身并不是一个对象，一旦定义了引用，就无法令其绑定到另外的对象，之后每次使用这个引用都是访问它最初绑定的那个对象。
    指针无须在定义时赋值，和其他内置类型一样，在块作用域内定义的指针如果没有被初始化，也将拥有一个不确定的值。
# 空指针不指向任何一个对象，在使用一个指针之前代码可以首先检查它是否为空。
# 建议初始化所有指针
# 指针需要与他所指的对象匹配，但:
    void*指针可以存放任意对象的地址。
    允许另一个指向常量的指针指向一个非常量的对象

# const
    默认状态下，const对象仅在文件内有效，多个文件共享const对象的话，变量定义前添加extern。
    const对象必须初始化。
# 引用必须与引用对象匹配，但是两个例外：
    初始化常量引用时，允许用任意表达式作为初始值，只要该表达式能转换成引用的类型就行。
# 对const的引用可能引用一个非const对象
# 顶层const和底层const
    顶层const指的是指针本身是一个常量
    底层const指的是指所指的对象是一个常量
# 2.4.4constexpr和常量表达式
    常量表达式是指值不会改变并且在编译的过程就能得到计算结果的表达式
    # constexpr变量
    C++11新标准规定，允许将变量声明为constexpr类型以便编译器验证变量的值是不是一个常量表达式。一般来说，你认定他是常量表达式，那就声明为constexpr类型。
# 2.5处理类型
## 2.5.1 类型别名：
    两种方式：
        typedef double a;
        using a = double;(C++11)
## 2.5.2 auto类型说明符
c++ 11新，让编译器分析表达式的类型
## 2.5.3decltype类型指示符
希望从表达式的类型推断出要定义的变量的类型，但是不想用该表达式的值初始化变量。
decltype (f()) sum = x;
decltype与引用
decltype的结果类型与表达式密切相关。对于decltype所用的表达式来说，如果变量名加上了一对括号，则得到的结果与不加括号时会有不同。
切记：decltype((val))的结果永远是引用。decltype(val)结果只有当val本身是一个引用时才是引用。
//切记 decltype(表达式) 表达式并不执行 

总结：auto与decltype的不同：
    auto推断出表达式类型并将表达式的值赋给变量，而decltype可以推断变量类型，并不赋值。
    decltype结果类型与表达式密切相关，比如两层括号就与一层括号不同。
# 2.6 自定义数据结构
可以为类内数据成员提供初始值，初始化的方式有两种：花括号或者赋值。
## 预处理器概述
    头文件一旦发生改变，相关的源文件必须重新编译
    确保头文件多次包含仍能正常工作的是预处理器。
    预处理功能：
        看到#include标记用指定的头文件内容代替#include
        头文件保护符，头文件保护符依赖于预处理变量，预处理变量两种状态：已定、未定义
        #ifdef #ifndef #enddef
    头文件即使没有被包含在任何文件中，也应该设置头文件保护符
